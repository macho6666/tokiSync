<script>
    const NO_IMAGE_SVG = "data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%3Crect%20width%3D%22100%22%20height%3D%22100%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%22%20y%3D%2250%22%20font-family%3D%22Arial%22%20font-size%3D%2212%22%20fill%3D%22%23666%22%20text-anchor%3D%22middle%22%20dy%3D%22.3em%22%3ENo%20Image%3C%2Ftext%3E%3C%2Fsvg%3E";
    const URL_NEWTOKI = 'https://newtoki469.com';
    const URL_MANATOKI = 'https://manatoki469.net';
    const URL_BOOKTOKI = 'https://booktoki469.com';

    let allSeries = [];
    let currentBookList = [];
    let currentBookIndex = -1;
    let viewerImages = [];
    let viewerPageIndex = 0;
    let nextBookPreload = null;

    // Feature Flags (State)
    let isScriptConnected = false;
    // let scriptCheckTimeout = null; // Deprecated

    // Ï¥àÍ∏∞Ìôî
    window.onload = function () {
        loadDomains();
        
        // 1. Îä•ÎèôÏ†Å Ìï∏ÎìúÏâêÏù¥ÌÅ¨ ÏãúÏûë (Ping-Pong)
        startHandshake();

        // 2. Î∂ÄÎ™®(Ïä§ÌÅ¨Î¶ΩÌä∏)Î°úÎ∂ÄÌÑ∞ Î©îÏãúÏßÄ ÎåÄÍ∏∞
        window.addEventListener("message", handleMessage, false);

        // 3. Î°úÏª¨ Ï∫êÏãú Ïö∞ÏÑ† Î°úÎìú (Îπ†Î•∏ ÌôîÎ©¥ ÌëúÏãú)
        const cachedId = localStorage.getItem('toki_folder_id');
        if (cachedId) {
            refreshDB(cachedId, true); // true = silent load (no spinner reset)
        }
    };

    function startHandshake() {
        let attempts = 0;
        const maxAttempts = 20; // 10Ï¥àÍ∞Ñ ÏãúÎèÑ (0.5s * 20)
        
        const interval = setInterval(() => {
            if (isScriptConnected || attempts >= maxAttempts) {
                clearInterval(interval);
                if (!isScriptConnected) {
                     // ÌÉÄÏûÑÏïÑÏõÉ: Ïä§ÌÅ¨Î¶ΩÌä∏ ÎØ∏Í∞êÏßÄ -> ÏÑ§Ï†ï Î™®Îã¨ (ÏàòÎèô)
                     checkLocalConfig();
                }
                return;
            }
            
            // Ping Î∞úÏÜ°
            // console.log("üì° Sending Ping...");
            window.postMessage({ type: 'TOKI_PING' }, '*');
            
            if (window.top !== window.self) {
                window.top.postMessage({ type: 'TOKI_PING' }, '*');
            }
            
            attempts++;
        }, 500); 
    }

    function handleMessage(event) {
        if (event.data.type === "TOKI_INIT") {
            isScriptConnected = true;

            // Ïó∞Í≤∞ ÌôïÏ†ï (Optional: ACK Î∞úÏÜ°)
            // window.postMessage({ type: 'TOKI_ACK' }, '*');

            const folderId = event.data.folderId;
            console.log("üîó Connected to Script. Root Folder ID:", folderId);
            
            // Ï†ÄÏû• Î∞è Î¶¨Î°úÎìú
            if (folderId && folderId !== localStorage.getItem('toki_folder_id')) {
                localStorage.setItem('toki_folder_id', folderId);
                showToast("üîó Ïä§ÌÅ¨Î¶ΩÌä∏ Ïó∞Í≤∞Îê® (ÏûêÎèô ÎèôÍ∏∞Ìôî)");
                refreshDB(folderId);
            } else {
                // Ïù¥ÎØ∏ Í∞ôÏùÄ IDÎ©¥ Î°úÎìúÎßå ÏàòÌñâ
                if (!allSeries.length) refreshDB(folderId);
            }
            updateFeatureUI();
        }
    }

    function checkLocalConfig() {
        // Ï†ÄÏû•Îêú Ìè¥Îçî IDÍ∞Ä ÏóÜÏúºÎ©¥ Î™®Îã¨ ÎùÑÏö∞Í∏∞
        if (!localStorage.getItem('toki_folder_id')) {
            document.getElementById('configModal').style.display = 'flex';
        } else {
            // ID ÏûàÏúºÎ©¥ Î°úÎìú ÏãúÎèÑ (ÌïòÏßÄÎßå Ïä§ÌÅ¨Î¶ΩÌä∏ ÏóÜÏúºÎØÄÎ°ú ÏùºÎ∂Ä Í∏∞Îä• Ï†úÌïú)
            showToast("‚ö†Ô∏è Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. (ÏùΩÍ∏∞ Ï†ÑÏö© Î™®Îìú)", 5000);
            updateFeatureUI();
        }
    }

    function saveConfig() {
        const id = document.getElementById('configFolderId').value.trim();
        if(!id) return alert("Folder IDÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.");
        localStorage.setItem('toki_folder_id', id);
        document.getElementById('configModal').style.display = 'none';
        refreshDB(id);
    }

    function updateFeatureUI() {
        const syncButtons = document.querySelectorAll('.sync-feature');
        const scriptRequired = document.querySelectorAll('.script-only');
        
        // Ïä§ÌÅ¨Î¶ΩÌä∏ ÏóÜÏúºÎ©¥ ÎèôÍ∏∞Ìôî Î≤ÑÌäº ÎπÑÌôúÏÑ±Ìôî Ïä§ÌÉÄÏùº Ï†ÅÏö©
        if (!isScriptConnected) {
             syncButtons.forEach(btn => btn.classList.add('script-required'));
             // PWA ÏÑ§Ïπò Î≤ÑÌäº ÌëúÏãúÎäî Î≥ÑÎèÑ Î°úÏßÅ (Ïó¨Í∏∞ÏÑúÎäî ÏÉùÎûµ)
        } else {
             syncButtons.forEach(btn => btn.classList.remove('script-required'));
        }
    }

    // Toast UI
    function showToast(msg, duration = 3000) {
        const toast = document.createElement('div');
        toast.style.position = 'fixed';
        toast.style.bottom = '20px';
        toast.style.left = '50%';
        toast.style.transform = 'translateX(-50%)';
        toast.style.background = 'rgba(50, 50, 50, 0.9)';
        toast.style.color = 'white';
        toast.style.padding = '10px 20px';
        toast.style.borderRadius = '20px';
        toast.style.zIndex = '9999';
        toast.style.fontSize = '14px';
        toast.innerText = msg;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
    }

    function refreshDB(forceId = null, silent = false) {
        const folderId = forceId || localStorage.getItem('toki_folder_id');
        if (!folderId) return;

        if (!silent) {
            const btn = document.getElementById('refreshBtn');
            btn.classList.add('spin-anim');
        }

        google.script.run
            .withSuccessHandler((data) => {
                if (!silent) document.getElementById('refreshBtn').classList.remove('spin-anim');
                renderGrid(data);
            })
            .withFailureHandler((e) => {
                if (!silent) document.getElementById('refreshBtn').classList.remove('spin-anim');
                showToast(`‚ùå Í∞±Ïã† Ïã§Ìå®: ${e.message}`, 5000);
            })
            .getSeriesList(folderId); // Use LibraryService
    }

    function toggleSettings() { document.getElementById('domainPanel').style.display = document.getElementById('domainPanel').style.display === 'block' ? 'none' : 'block'; }
    function saveDomains() {
        localStorage.setItem('url_newtoki', document.getElementById('url_newtoki').value.trim());
        localStorage.setItem('url_manatoki', document.getElementById('url_manatoki').value.trim());
        localStorage.setItem('url_booktoki', document.getElementById('url_booktoki').value.trim());
        renderGrid(allSeries);
    }

    function loadDomains() {
        const n = localStorage.getItem('url_newtoki');
        const m = localStorage.getItem('url_manatoki');
        const b = localStorage.getItem('url_booktoki');

        document.getElementById('url_newtoki').value = n ? n : URL_NEWTOKI;
        document.getElementById('url_manatoki').value = m ? m : URL_MANATOKI;
        document.getElementById('url_booktoki').value = b ? b : URL_BOOKTOKI;
    }

    function getDynamicLink(series) {
        const contentId = series.sourceId;

        const site = (series.name || "").toLowerCase(); // Simple check from name?
        let baseUrl = document.getElementById('url_manatoki').value;
        let path = "/comic/";

        if (site.includes("Îâ¥ÌÜ†ÎÅº")) { baseUrl = document.getElementById('url_newtoki').value; path = "/webtoon/"; }
        else if (site.includes("Î∂ÅÌÜ†ÎÅº")) { baseUrl = document.getElementById('url_booktoki').value; path = "/novel/"; }

        if (baseUrl.endsWith("/")) baseUrl = baseUrl.slice(0, -1);
        return contentId ? (baseUrl + path + contentId) : "#";
    }

    function renderGrid(seriesList) {
        allSeries = seriesList;
        const grid = document.getElementById('grid');
        grid.innerHTML = '';

        if (!seriesList || seriesList.length === 0) {
            grid.innerHTML = '<div class="no-data">Ï†ÄÏû•Îêú ÏûëÌíàÏù¥ ÏóÜÏäµÎãàÎã§.</div>';
            document.getElementById('pageLoader').style.display = 'none';
            return;
        }

        seriesList.forEach((series, index) => {
            try {
                const card = document.createElement('div');
                card.className = 'card';

                // Defensive Coding
                const meta = series.metadata || { status: 'Unknown', authors: [] };
                const authors = meta.authors || [];
                const status = meta.status || 'Unknown';

                const thumb = series.thumbnail && series.thumbnail.startsWith("data:image") ? series.thumbnail : NO_IMAGE_SVG;
                const dynamicUrl = getDynamicLink(series);
                const hasContentId = !!series.sourceId;

                card.innerHTML = `
      <div class="thumb-wrapper">
        <img src="${thumb}" class="thumb" onerror="this.src='${NO_IMAGE_SVG}'">
        <div class="overlay">
          <a href="${series.url}" target="_blank" class="btn btn-drive">üìÇ ÎìúÎùºÏù¥Î∏å</a>
          <button onclick="openEpisodeList('${series.id}', '${series.name}', ${index})" class="btn" style="background:#444; color:white;">üìÑ Î™©Î°ù</button>
          ${hasContentId ? `
              <a href="${dynamicUrl}" target="_blank" class="btn btn-site">üåê ÏÇ¨Ïù¥Ìä∏</a>
              <a href="${dynamicUrl}?toki_action=sync" target="_blank" class="btn sync-feature" style="background:#ff9800; color:black;">‚ö°Ô∏è ÎèôÍ∏∞Ìôî</a>
          ` : ''}
        </div>
      </div>
      <div class="info">
        <div class="title" title="${series.name}">${series.name}</div>
        <span class="author" title="${authors.join(', ')}">${authors.join(', ') || 'ÏûëÍ∞Ä ÎØ∏ÏÉÅ'}</span>
        <div class="meta">
          <span class="badge">${status}</span>
          <span class="count">${series.booksCount || 0}Í∂å</span>
        </div>
      </div>
    `;
                grid.appendChild(card);
            } catch (err) {
                console.error("Error rendering item index " + index, err);
            }
        });
        updateFeatureUI(); // Î†åÎçîÎßÅ ÌõÑ Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        document.getElementById('pageLoader').style.display = 'none';
    }

    function filterData() {
        const query = document.getElementById('search').value.toLowerCase();
        const cards = document.querySelectorAll('.card');
        cards.forEach((card, index) => {
            const series = allSeries[index];
            const meta = series.metadata || { authors: [] };
            const authors = meta.authors || [];
            const text = (series.name + (authors.join(' '))).toLowerCase();
            card.style.display = text.includes(query) ? 'flex' : 'none';
        });
    }
    function togglePwaGuide() {
        const guide = document.getElementById('pwaGuide');
        if (guide.style.display === 'block') {
            guide.style.display = 'none';
        } else {
            guide.style.display = 'block';
        }
    }

    // [Episode List Logic]
    function openEpisodeList(seriesId, title, seriesIndex) {
        document.getElementById('episodeModal').style.display = 'flex';
        document.querySelector('#episodeModal .modal-title').innerText = `üìÑ ${title}`;
        const listEl = document.getElementById('episodeList');
        listEl.innerHTML = '<div style="padding:20px; color:#888;">Î°úÎî© Ï§ë...</div>';
        console.log('seriesId', seriesId);
        console.log('title', title);
        console.log('seriesIndex', seriesIndex);
        google.script.run
            .withSuccessHandler((books) => {
                document.querySelector('#episodeModal .modal-title').innerText = `üìÑ ${title} (${books ? books.length : 0}Í∞ú)`;
                renderEpisodeList(books, seriesIndex);
            })
            .withFailureHandler(e => {
                listEl.innerHTML = `<div style="padding:20px; color:red;">Ïò§Î•ò: ${e.message}</div>`;
            })
            .getBooks(seriesId); // Use BookService
    }

    function closeEpisodeModal() {
        document.getElementById('episodeModal').style.display = 'none';
    }

    // [Old renderEpisodeList removed - see below]

    function formatSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    // [Advanced Viewer Logic]
    
    // Viewer State
    let vState = {
        mode: '1page', // '1page' or '2page'
        coverPriority: true,
        images: [], // Array of {src, width, height, loaded}
        spreads: [], // Array of arrays containing image indices [0], [1,2] etc.
        currentSpreadIndex: 0,
        settingsTimer: null
    };

    // Load Settings from LocalStorage
    function loadViewerSettings() {
        vState.mode = localStorage.getItem('toki_v_mode') || '1page';
        vState.coverPriority = (localStorage.getItem('toki_v_cover') === 'true');
        
        // UI Sync
        document.getElementById('chkTwoPage').checked = (vState.mode === '2page');
        document.getElementById('chkCover').checked = vState.coverPriority;
        document.getElementById('groupCover').style.display = (vState.mode === '2page') ? 'flex' : 'none';
    }

    // Toggle Settings UI
    function showViewerSettings() {
        const panel = document.getElementById('viewerSettings');
        panel.classList.add('visible');
        clearTimeout(vState.settingsTimer);
        // Auto hide after 3 seconds if not interacted
        vState.settingsTimer = setTimeout(() => panel.classList.remove('visible'), 3000);
    }

    function toggleViewerSettings() {
        const panel = document.getElementById('viewerSettings');
        if (panel.classList.contains('visible')) panel.classList.remove('visible');
        else showViewerSettings();
    }

    function toggleViewMode() {
        vState.mode = document.getElementById('chkTwoPage').checked ? '2page' : '1page';
        document.getElementById('groupCover').style.display = (vState.mode === '2page') ? 'flex' : 'none';
        localStorage.setItem('toki_v_mode', vState.mode);
        recalcSpreads();
    }

    function toggleCoverMode() {
        vState.coverPriority = document.getElementById('chkCover').checked;
        localStorage.setItem('toki_v_cover', String(vState.coverPriority));
        recalcSpreads();
    }

    // History Logic
    function getReadHistory(seriesId) {
        const json = localStorage.getItem(`read_${seriesId}`);
        return json ? JSON.parse(json) : {};
    }

    function saveReadHistory(seriesId, bookId) {
        let history = getReadHistory(seriesId);
        history[bookId] = true;
        localStorage.setItem(`read_${seriesId}`, JSON.stringify(history));
    }

    async function loadViewer(index) {
        const book = currentBookList[index];
        if (!book) return;

        closeEpisodeModal(); // Close list if open
        currentBookIndex = index;
        
        loadViewerSettings(); // Init Settings

        const viewer = document.getElementById('viewerOverlay');
        const content = document.getElementById('viewerContent');
        
        viewer.style.display = 'flex';
        document.body.classList.add('no-scroll');

        // Initial UI
        content.innerHTML = `
            <div class="nav-zone nav-prev" onclick="navigateViewer(-1)"></div>
            <div class="nav-zone nav-next" onclick="navigateViewer(1)"></div>
            <div id="viewerImageContainer" class="viewer-image-container">
                 <div style="color:white; font-size:14px;">Î°úÎî© Ï§ë... (0%)</div>
            </div>
            <div id="pageCounter" class="page-counter">- / -</div>
        `;

        try {
            let blobUrls = [];
            // Check Preload
            if (nextBookPreload && nextBookPreload.index === index) {
                console.log("Using preloaded data!");
                blobUrls = nextBookPreload.images;
                nextBookPreload = null;
            } else {
                blobUrls = await fetchAndUnzip(book.id, (progress) => {
                    const el = document.querySelector('#viewerImageContainer div');
                    if (el) el.innerText = progress;
                });
            }

            if (blobUrls.length === 0) throw new Error("Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");

            // Mark as Read
            saveReadHistory(book.seriesId, book.id);

            // Pre-process images for dimensions (needed only for 2-page mode smart spread)
            // But doing it lazily is hard for spread calculation. 
            // We'll calculate spreads naively first, and optimize if we have dimensions.
            // For web app, creating Image objects is fast.
            
            vState.images = blobUrls.map(url => ({ src: url, width: 0, height: 0, loaded: false }));
            
            // Wait for dimensions if 2-page mode? 
            // Better strategy: Just load spreads. If 1.2 requirement (Landscape) is critical, 
            // we need dimensions. Let's try to get dimensions for creating smart spreads.
            // However, loading ALL images details might be slow. 
            // compromise: Recalculate spread "on the fly" or just assume portrait for now.
            // USER REQUEST 1.2: "ÎßåÏïΩ Í∞ÄÎ°ú ÎπÑÏú®Ïù¥ ÏÑ∏Î°ú Î≥¥Îã§ ÌÅ∞Í≤ΩÏö∞... Ìï©Ïπú Ïù¥ÎØ∏ÏßÄÎ°ú ÌåêÎã®"
            // To do this, we need to know the aspect ratio.
            
            await preloadDimensions(vState.images); // Optional: Fast preload for header info?
            // Actually loading all images might take time.
            // Let's implement lazy spread calculation? 
            // For now, let's load dimensions of the FIRST few images, but really we need all for correct spread paging.
            // Since these are blob URLs from local zip, loading metadata is instant.
            
            await loadAllImageDimensions(vState.images);
            
            recalcSpreads(true); // Reset to page 0

        } catch (e) {
            alert("Î∑∞Ïñ¥ Î°úÎìú Ïã§Ìå®: " + e.message);
            closeViewer();
        }
    }

    function loadAllImageDimensions(images) {
        const promises = images.map(imgData => {
            return new Promise(resolve => {
                 const img = new Image();
                 img.onload = () => {
                     imgData.width = img.naturalWidth;
                     imgData.height = img.naturalHeight;
                     imgData.loaded = true;
                     resolve();
                 };
                 img.onerror = resolve; // Continue even if error
                 img.src = imgData.src;
            });
        });
        return Promise.all(promises);
    }

    function recalcSpreads(resetPage = false) {
        vState.spreads = [];
        const images = vState.images;
        
        if (vState.mode === '1page') {
            for(let i=0; i<images.length; i++) vState.spreads.push([i]);
        } else {
            // 2-page mode
            let i = 0;
            // 1.1 Cover Priority
            if (vState.coverPriority && images.length > 0) {
                 vState.spreads.push([0]);
                 i = 1;
            }
            
            while (i < images.length) {
                const current = images[i];
                // 1.2 Landscape Detection (Spread)
                if (current.width > current.height) {
                    vState.spreads.push([i]);
                    i++;
                    continue;
                }
                
                // Pair check
                if (i + 1 < images.length) {
                    const next = images[i+1];
                    // If next is landscape, don't pair.
                    if (next.width > next.height) {
                         vState.spreads.push([i]);
                         i++;
                    } else {
                         vState.spreads.push([i, i+1]);
                         i += 2;
                    }
                } else {
                    // Last single page
                    vState.spreads.push([i]);
                    i++;
                }
            }
        }
        
        if (resetPage) vState.currentSpreadIndex = 0;
        else {
             // Try to keep current position? (Simple: reset to 0 or calc based on current image index)
             // Complex logic omitted for brevity, resetting to 0 for safety on mode switch
             vState.currentSpreadIndex = 0; 
        }
        
        renderCurrentSpread();
    }

    function renderCurrentSpread() {
        if (!vState.spreads || vState.spreads.length === 0) return;
        
        const container = document.getElementById('viewerImageContainer');
        const counter = document.getElementById('pageCounter');
        
        const spreadIndices = vState.spreads[vState.currentSpreadIndex]; // e.g. [2, 3]
        
        container.innerHTML = `<div class="viewer-spread">
            ${spreadIndices.map(idx => `
                <img src="${vState.images[idx].src}" class="viewer-page ${spreadIndices.length > 1 ? 'half' : ''}">
            `).join('')}
        </div>`;
        
        // Update Counter (Displaying real page numbers)
        const startPage = spreadIndices[0] + 1;
        const endPage = spreadIndices[spreadIndices.length-1] + 1;
        const total = vState.images.length;
        counter.innerText = (startPage === endPage) ? `${startPage} / ${total}` : `${startPage}-${endPage} / ${total}`;

        // 3. Preload Trigger (Left <= 7 pages, ~3-4 spreads)
        if (vState.spreads.length - vState.currentSpreadIndex <= 4) {
             preloadNextEpisode();
        }
    }

    function navigateViewer(dir) {
        const nextIdx = vState.currentSpreadIndex + dir;
        
        if (nextIdx >= vState.spreads.length) {
            // End of Episode
            if (currentBookIndex < currentBookList.length - 1) {
                 if (confirm("Îã§Ïùå ÌôîÎ°ú Ïù¥ÎèôÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
                     loadViewer(currentBookIndex + 1);
                 }
            } else {
                 showToast("ÎßàÏßÄÎßâ ÌôîÏûÖÎãàÎã§.");
            }
            return;
        }
        
        if (nextIdx < 0) {
            showToast("Ï≤´ ÌéòÏù¥ÏßÄÏûÖÎãàÎã§.");
            return;
        }
        
        vState.currentSpreadIndex = nextIdx;
        renderCurrentSpread();
    }

    function preloadNextEpisode() {
        const nextIndex = currentBookIndex + 1;
        if (nextIndex >= currentBookList.length) return;
        if (nextBookPreload && nextBookPreload.index === nextIndex) return;
        if (window.isPreloading) return;

        console.log("Preloading next episode:", currentBookList[nextIndex].name);
        window.isPreloading = true;

        fetchAndUnzip(currentBookList[nextIndex].id, null)
            .then(blobUrls => {
                nextBookPreload = { index: nextIndex, images: blobUrls };
                console.log("Preload complete");
                showToast("üì¶ Îã§Ïùå Ìôî Ï§ÄÎπÑ ÏôÑÎ£å!", 3000);
                window.isPreloading = false;
            })
            .catch(e => {
                console.error("Preload failed", e);
                window.isPreloading = false;
            });
    }

    function closeViewer() {
        const viewer = document.getElementById('viewerOverlay');
        const content = document.getElementById('viewerContent');
        
        // Cleanup Blobs
        if (vState.images) {
            vState.images.forEach(img => URL.revokeObjectURL(img.src));
        }
        vState.images = [];
        vState.spreads = [];
        
        content.innerHTML = '';
        viewer.style.display = 'none';
        document.body.classList.remove('no-scroll');
        
        // Refresh markers in list if open? 
        // We might want to close the viewer and verify success, but the list is separate.
    }

    // Global Key Connect
    document.addEventListener('keydown', (e) => {
        const overlay = document.getElementById('viewerOverlay');
        if (overlay && overlay.style.display === 'flex') {
            if (e.key === 'Escape') closeViewer();
            else if (e.key === 'ArrowLeft') navigateViewer(-1);
            else if (e.key === 'ArrowRight') navigateViewer(1);
            else if (e.key === ' ' || e.key === 'Enter') navigateViewer(1);
            // Hide Settings on keypress
            const panel = document.getElementById('viewerSettings');
            if(panel.classList.contains('visible')) panel.classList.remove('visible');
        } else if (document.getElementById('episodeModal').style.display === 'flex') {
             if (e.key === 'Escape') closeEpisodeModal();
        }
    });
    
    // [Integration] Render Episode List with History
    function renderEpisodeList(books, seriesIndex) {
        currentBookList = books || [];
        const seriesId = allSeries[seriesIndex].id; // Get ID for history key
        const history = getReadHistory(seriesId);

        const listEl = document.getElementById('episodeList');
        listEl.innerHTML = '';

        if (!books || books.length === 0) {
            listEl.innerHTML = '<div style="padding:20px; color:#888;">ÌëúÏãúÌï† ÌöåÏ∞®Í∞Ä ÏóÜÏäµÎãàÎã§.</div>';
            return;
        }

        books.forEach((book, index) => {
            try {
                const div = document.createElement('div');
                div.className = 'episode-item';
                // Attach seriesId to book for easier history saving
                book.seriesId = seriesId; 

                let icon = 'üìÅ';
                let meta = 'Ìè¥Îçî';
                let clickHandler = () => window.open(book.url, '_blank');
                let isRead = history[book.id];

                if (book.media && book.media.mediaType && !book.media.mediaType.includes('folder')) {
                    icon = 'üì¶';
                    meta = (typeof formatSize === 'function') ? formatSize(book.size) : (book.size + ' B');

                    if (book.name.toLowerCase().endsWith('.cbz') || book.name.toLowerCase().endsWith('.zip')) {
                        icon = 'üìñ';
                        clickHandler = () => {
                             // Direct load without confirm for better UX? Or keep confirm?
                             // User didn't specify removing confirm, but speed is king.
                             // Keeping direct load for smoothness.
                             loadViewer(index);
                        };
                    }
                } else { icon = 'üìÅ'; }

                div.innerHTML = `
                    <div>
                        <span style="margin-right:10px;">${icon}</span>
                        <span class="ep-name" style="${isRead ? 'color:#888;' : ''}">${book.name}</span>
                        ${isRead ? '<span class="read-badge active">READ</span>' : ''}
                    </div>
                    <span class="ep-meta">${meta}</span>
                `;
                div.onclick = clickHandler;
                listEl.appendChild(div);

            } catch (err) {
                console.error("Error rendering item " + index, err);
            }
        });
    }

    // Helper: formatSize is already there? Yes in previous code.
    // Keeping formatSize if it was outside. 
    // Wait, I am replacing lines 354 to 562. formatSize was at 345. It is SAFE.

</script>
